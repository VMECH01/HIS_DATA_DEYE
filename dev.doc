// Updated fetchDeviceData with batching and merging
async function fetchDeviceData(deviceSn, stationId, measurePoints = ["BatteryVoltage", "LoadPowerL1", "LoadPowerL2", "LoadPowerL3", "GridPowerL1", "GridPowerL2", "GridPowerL3"]) {
  const { startTimestamp, endTimestamp } = getTimestamps();
  
  // Batch measurePoints to avoid API limits (e.g., 3 per batch; adjust based on API docs)
  const batchSize = 3; // Test and adjust (e.g., if 4 works, increase)
  const pointBatches = [];
  for (let i = 0; i < measurePoints.length; i += batchSize) {
    pointBatches.push(measurePoints.slice(i, i + batchSize));
  }

  // If time range is too long, split into sub-ranges (e.g., 6-hour chunks)
  const timeRangeHours = 24; // Full day
  const subRangeHours = 6; // Adjust if needed (e.g., 12 for fewer requests)
  const subRanges = [];
  for (let start = startTimestamp; start < endTimestamp; start += subRangeHours * 3600) {
    const end = Math.min(start + subRangeHours * 3600, endTimestamp);
    subRanges.push({ startTimestamp: start, endTimestamp: end });
  }

  let attempts = 0;
  while (attempts < CONFIG.RETRY_ATTEMPTS) {
    try {
      logger.info(`Fetching data for device: ${deviceSn} in station: ${stationId} (Attempt ${attempts + 1})`);
      
      // Collect all data across batches
      const allDataLists = [];
      for (const pointBatch of pointBatches) {
        for (const timeRange of subRanges) {
          const payload = { deviceSn, startTimestamp: timeRange.startTimestamp, endTimestamp: timeRange.endTimestamp, measurePoints: pointBatch };
          logger.info(`Fetching batch: ${JSON.stringify(pointBatch)} for time ${timeRange.startTimestamp}-${timeRange.endTimestamp}`);
          
          const response = await deyePost("/device/historyRaw", payload, { timeout: CONFIG.API_TIMEOUT });
          if (!response || response.code !== "1000000" || !response.dataList) {
            throw new Error(`Invalid API response for batch ${JSON.stringify(pointBatch)}: ${JSON.stringify(response)}`);
          }
          allDataLists.push(...response.dataList); // Merge dataLists
        }
      }

      // Upsert Device (unchanged)
      const [dbDevice, created] = await Device.upsert({
        device_sn: response.deviceSn, // Note: Use the last response's deviceSn; assumes consistency
        device_type: response.deviceType,
        station_id: stationId,
      });
      logger.info(`Device ${deviceSn} ${created ? 'created' : 'updated'} in DB for station ${stationId}`);

      // Create table (unchanged, but ensure it includes all columns)
      const tableName = `measurements_station_${stationId}`;
      const createTableQuery = `
        CREATE TABLE IF NOT EXISTS ${tableName} (
          measurement_id SERIAL PRIMARY KEY,
          device_sn VARCHAR(255) NOT NULL,
          timestamp BIGINT NOT NULL,
          BatteryVoltage DECIMAL(10, 2),
          LoadPowerL1 DECIMAL(10, 2),
          LoadPowerL2 DECIMAL(10, 2),
          LoadPowerL3 DECIMAL(10, 2),
          GridPowerL1 DECIMAL(10, 2),
          GridPowerL2 DECIMAL(10, 2),
          GridPowerL3 DECIMAL(10, 2),
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          UNIQUE (device_sn, timestamp)
        );
        CREATE INDEX IF NOT EXISTS idx_device_sn ON ${tableName} (device_sn);
        CREATE INDEX IF NOT EXISTS idx_timestamp ON ${tableName} (timestamp);
      `;
      await sequelize.query(createTableQuery);
      logger.info(`Ensured table ${tableName} exists`);

      // Group and merge measurements by timestamp (across all batches)
      const timestampMap = {};
      allDataLists.forEach(dataPoint => {
        const timestamp = parseInt(dataPoint.time);
        if (!timestampMap[timestamp]) {
          timestampMap[timestamp] = { 
            device_sn: deviceSn, 
            timestamp, 
            BatteryVoltage: null, 
            LoadPowerL1: null, 
            LoadPowerL2: null, 
            LoadPowerL3: null, 
            GridPowerL1: null, 
            GridPowerL2: null, 
            GridPowerL3: null 
          };
        }
        dataPoint.itemList.forEach(item => {
          if (isNaN(parseFloat(item.value))) {
            logger.warn(`Skipping invalid value for ${deviceSn} at ${timestamp}: ${item.value}`);
            return;
          }
          // Map keys to columns
          if (item.key === 'BatteryVoltage') timestampMap[timestamp].BatteryVoltage = parseFloat(item.value);
          else if (item.key === 'LoadPowerL1') timestampMap[timestamp].LoadPowerL1 = parseFloat(item.value);
          else if (item.key === 'LoadPowerL2') timestampMap[timestamp].LoadPowerL2 = parseFloat(item.value);
          else if (item.key === 'LoadPowerL3') timestampMap[timestamp].LoadPowerL3 = parseFloat(item.value);
          else if (item.key === 'GridPowerL1') timestampMap[timestamp].GridPowerL1 = parseFloat(item.value);
          else if (item.key === 'GridPowerL2') timestampMap[timestamp].GridPowerL2 = parseFloat(item.value);
          else if (item.key === 'GridPowerL3') timestampMap[timestamp].GridPowerL3 = parseFloat(item.value);
          // Add more mappings if needed
        });
      });

      // Prepare for bulk upsert
      const measurements = Object.values(timestampMap);
      if (measurements.length > 0) {
        const values = measurements.map(m => 
          `('${m.device_sn}', ${m.timestamp}, ${m.BatteryVoltage || 'NULL'}, ${m.LoadPowerL1 || 'NULL'}, ${m.LoadPowerL2 || 'NULL'}, ${m.LoadPowerL3 || 'NULL'}, ${m.GridPowerL1 || 'NULL'}, ${m.GridPowerL2 || 'NULL'}, ${m.GridPowerL3 || 'NULL'})`
        ).join(', ');
        const upsertQuery = `
          INSERT INTO ${tableName} (device_sn, timestamp, BatteryVoltage, LoadPowerL1, LoadPowerL2, LoadPowerL3, GridPowerL1, GridPowerL2, GridPowerL3)
          VALUES ${values}
          ON CONFLICT (device_sn, timestamp) DO UPDATE SET
            BatteryVoltage = EXCLUDED.BatteryVoltage,
            LoadPowerL1 = EXCLUDED.LoadPowerL1,
            LoadPowerL2 = EXCLUDED.LoadPowerL2,
            LoadPowerL3 = EXCLUDED.LoadPowerL3,
            GridPowerL1 = EXCLUDED.GridPowerL1,
            GridPowerL2 = EXCLUDED.GridPowerL2,
            GridPowerL3 = EXCLUDED.GridPowerL3,
            updated_at = CURRENT_TIMESTAMP;
        `;
        await sequelize.query(upsertQuery);
        logger.info(`Upserted ${measurements.length} merged measurements into ${tableName}`);
      } else {
        logger.warn(`No measurements to insert for ${deviceSn}`);
      }
      return { deviceSn, allDataLists };
    } catch (err) {
      attempts++;
      logger.warn(`Attempt ${attempts} failed for ${deviceSn}: ${err.message}`);
      if (attempts >= CONFIG.RETRY_ATTEMPTS) {
        logger.error(`Failed to fetch/store data for ${deviceSn} after ${CONFIG.RETRY_ATTEMPTS} attempts`, { error: err.message });
        throw err;
      }
      await new Promise(resolve => setTimeout(resolve, CONFIG.RETRY_DELAY * Math.pow(2, attempts - 1)));
    }
  }
}